using Bogus;
using WebApi.Domain.Entities;
using WebApi.Domain.Interfaces.Common;
using WebApi.Domain.Interfaces.Services;

namespace WebApi.Service.Services
{
    public class CuttingDownAService : ICuttingDownAService
    {
        private readonly IUnitOfWork _unitOfWork;

        public CuttingDownAService(IUnitOfWork unitOfWork)
        {
            _unitOfWork = unitOfWork;
        }

        public async Task<bool> GenerateCabinCuttingsAsync()
        {
            if (await _unitOfWork.CuttingDownARepository.ExistsAsync(x => true))
                return false;

            // Fetch existing data from the database
            var problemTypes = await _unitOfWork.IstaProblemTypeRepository.GetAllAsync();
            var cabins = await _unitOfWork.CabinRepository.GetAllAsync(); // Get all cabins

            var baseCreateDate = DateOnly.FromDateTime(DateTime.Now.AddDays(-365)); // 365 days ago

            var cuttingFaker = new Faker<CuttingDownA>()
                .StrictMode(true)
                .RuleFor(c => c.CuttingDownCabinName, f => f.PickRandom(cabins).CabinName) // Pick from existing cabins
                .RuleFor(c => c.ProblemTypeKey, f => f.PickRandom(problemTypes).ProblemTypeKey) // Pick random problem types
                .RuleFor(c => c.CreateDate, f => baseCreateDate.AddDays(f.Random.Int(1, 30))) // Random CreateDate within the past year
                .RuleFor(c => c.EndDate, (f, c) =>
                {
                    // 50% chance of having an EndDate, which will always be after CreateDate and before today
                    if (f.Random.Bool())
                        return c.CreateDate!.Value.AddDays(f.Random.Int(1, 15))
                            .CompareTo(DateOnly.FromDateTime(DateTime.Now)) < 0
                            ? c.CreateDate!.Value.AddDays(f.Random.Int(1, 15))
                            : null;
                    return null;
                })
                .RuleFor(c => c.IsGlobal, f => f.Random.Bool())
                .RuleFor(c => c.IsPlanned, f => f.Random.Bool())
                .RuleFor(c => c.IsActive, (f, c) => c.EndDate != null) // Active only if there’s an EndDate
                .RuleFor(c => c.PlannedStartDts, (f, c) =>
                    c.IsPlanned!.Value ? c.CreateDate!.Value.AddDays(f.Random.Int(-2, 0)) : null)
                .RuleFor(c => c.PlannedEndDts, (f, c) =>
                {
                    // If there's no EndDate and IsPlanned is true, PlannedEndDTS should be after today
                    if (c.IsPlanned!.Value && c.EndDate == null)
                        return DateOnly.FromDateTime(DateTime.Now).AddDays(f.Random.Int(1, 15));
                    return null;
                })
                // Ignore the identity column (CuttingDownAIncidentId) to prevent validation errors
                .Ignore(c => c.CuttingDownAIncidentId) // Ignore the primary key, as it's auto-generated by the DB
                .Ignore(c => c.CreatedUser)
                .Ignore(c => c.UpdatedUser)
                .Ignore(c => c.ProblemTypeKeyNavigation);

            var cuttings = cuttingFaker.Generate(50);

            // Add the generated data to the database
            _unitOfWork.CuttingDownARepository.AddRange(cuttings);
            await _unitOfWork.SaveChangesAsync();

            return true;
        }
    }
}
